#import binjson;
#import packing;

ParsingState {
    W:i,
    [Str]:strs
}

// normal bitshift is broken in Epsilon
Z#polyfill <Z:a> left bitshift <W:b> {
    for (W:i to b) {
        a *= 2;
    };
    return a;
}

W#take_VW_uint<Str:data><ParsingState:state> {
    W:result = 0;
    W:shift = 0;
    while (true) {
        if ([data].len == state.i) {
            abort "Invalid BinJSON VW int";
        };
        Byte:curByte = data[state.i++];
        result += polyfill [[curByte] & [127]] left bitshift [shift];
        shift += 7;
        if ([curByte] & [128] == 0) {
            return result;
        };
    };
}

Str#take_Str<Str:data><ParsingState:state> {
    W:idx = take_VW_uint[data][state];
    if (idx >= [state.strs].len) {
        abort "Invalid BinJSON string index";
    };
    return state.strs[idx];
}

Str#take_bytes<Str:data><ParsingState:state><W:count> {
    W:start = state.i;
    state.i += count;
    if (state.i > [data].len) {
        abort "Invalid BinJSON";
    };
    return [data].slice[start][state.i-1];
}

Byte#take_byte<Str:data><ParsingState:state> {
    if ([data].len == state.i) {
        abort "Invalid BinJSON";
    };
    return data[state.i++];
}

BinJSONBool#parse_BinJSONBool<Str:data><ParsingState:state> {
    return BinJSONBool [(Bool)take_byte[data][state]];
}

BinJSONDouble#parse_BinJSONDouble<Str:data><ParsingState:state> {
    Q:val = unpack_double[data][state.i];
    state.i += 8;
    return BinJSONDouble [val];
}

BinJSONInt#parse_BinJSONInt<Str:data><ParsingState:state> {
    return BinJSONInt[(Z)take_VW_uint[data][state]];
}

BinJSONList#parse_BinJSONList<Str:data><ParsingState:state> {
    W:len = take_VW_uint[data][state];
    [BinJSON]:items = [BinJSON] [];
    if (len > 0) {
        Byte:sub_id = take_byte[data][state];
        for (W:i to len) {
            [items].append[parse_BinJSON_val[sub_id][data][state]];
        };
    };
    return BinJSONList [items];
}

BinJSONList#parse_BinJSONList_multityped<Str:data><ParsingState:state> {
    W:len = take_VW_uint[data][state];
    [BinJSON]:items = [BinJSON] [];
    if (len > 0) {
        for (W:i to len) {
            Byte:sub_id = take_byte[data][state];
            [items].append[parse_BinJSON_val[sub_id][data][state]];
        };
    };
    return BinJSONList [items];
}

BinJSONObj#parse_BinJSONObj<Str:data><ParsingState:state> {
    W:len = take_VW_uint[data][state];
    [Str]:keys = [Str] [];
    [BinJSON]:values = [BinJSON] [];
    for (W:i to len) {
        [keys].append[take_Str[data][state]];
        Byte:val_id = take_byte[data][state];
        [values].append[parse_BinJSON_val[val_id][data][state]];
    };
    return BinJSONObj [keys, values];
}

BinJSONStr#parse_BinJSONStr<Str:data><ParsingState:state> {
    return BinJSONStr [take_Str[data][state]];
}

BinJSON#parse_BinJSON_val<Byte:id><Str:data><ParsingState:state> {
    switch (id)
    (1) {
        return BinJSON [parse_BinJSONBool[data][state], null, null, null, null, null, null];
    }
    (2) {
        return BinJSON [null, parse_BinJSONDouble[data][state], null, null, null, null, null];
    }
    (3) {
        return BinJSON [null, null, parse_BinJSONInt[data][state], null, null, null, null];
    }
    (4) {
        return BinJSON [null, null, null, parse_BinJSONList[data][state], null, null, null];
    }
    (5) {
        return BinJSON [null, null, null, null, BinJSONNull [], null, null];
    }
    (6) {
        return BinJSON [null, null, null, null, null, parse_BinJSONObj[data][state], null];
    }
    (7) {
        return BinJSON [null, null, null, null, null, null, parse_BinJSONStr[data][state]];
    }
    (8) {
        return BinJSON [null, null, null, parse_BinJSONList_multityped[data][state], null, null, null];
    }
    {
        abort "Invalid BinJSON ID";
    };
}
